import cv2

from OpenCV_learning.generalFunctions import show

"""
SIFT 图像尺度空间
DOG 高斯差分金字塔：两个高斯滤波结果做差分
SIFT算法求解尺度空间的极值点，每个像素点要和其图像域（同一尺度空间）和尺度域（相邻的尺度空间）的所有相邻点进行比较。
    当其大于或者小于所有相邻点时，该点就是极值点。
消除边界相应：主曲率比值大于10的特征点将被删除
特征点的主方向：每个特征点可以得到三个信息x,y,theta即位置，尺度和方向。具有多个方向点关键点可以被复制成多份，然后将方向值分别赋给复制后
    的特征点，一个特征点就产生了多个坐标，尺度相等，但是方向不同的特征点。
生成特征描述：在完成关键点的梯度计算之后，使用直方图统计邻域内像素的梯度和方向。
    为了保证特征矢量的旋转不变性，要以特征点为中心，在附近邻域内将坐标轴旋转一定角度，即将坐标轴旋转为特征点的主方向（特征向量分布最多的方向就是主方向）
    旋转之后的主方向为中心取8*8的窗口，求每个像素的梯度幅值和方向，箭头方向代表梯度方向，长度代表梯度幅值，然后利用高斯窗口对其进行加权运算
    ，最后在每个4*4的小块上绘制8个方向的梯度直方图，计算每个梯度方向的累加值，即可形成一个种子点，即每个特征点由四个种子点组成，每个种子点
    有8个方向的向量信息。
    建议对每个关键点使用4*4共16个种子点来描述，这样一个关键点就可以产生128维的SIFT特征向量。
"""

"""
sift实现关键点检测
"""
img = cv2.imread('field.png')
img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
# sift实例化
sift = cv2.SIFT_create()
kp = sift.detect(img_gray, None)
cv2.drawKeypoints(img_gray, kp, img)

show('res', img)
"""
计算特征
"""
kp, des = sift.compute(img_gray, kp)
"""
或者直接检测并且计算
"""
kp1, dst1 = sift.detectAndCompute(img_gray, None)
